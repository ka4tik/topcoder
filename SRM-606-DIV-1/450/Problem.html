<html><body bgcolor="#000000" text="#ffffff"><table><tr><td colspan="2"><h3>Problem Statement</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><i>Please note that this problem has a non-standard memory limit: 16 megabytes.</i><br></br><br></br>

Elly is quite excited! She is about to participate in an awesome initiative: several universities from all around the world are collaborating on a pair-programming project. Now the organizers of the initiative want to form the pairs (teams of two people) that will work on the project.<br></br><br></br>

Any two people may be paired, regardless of whether they are from the same university or not. However, it is awkward when the two teammates share the same name. Therefore the organizers would like to maximize the number of pairs such that the two paired participants have different names.<br></br><br></br>

There are <b>M</b> different possible names, <b>M</b> being an exact power of two (e.g., 1, 2, 32, 131072, 1073741824). For simplicity, we will represent each name as a number between 0 and <b>M</b>-1, inclusive. You are given the int <b>M</b> and the vector &lt;int&gt;s <b>count</b>, <b>first</b>, <b>mult</b>, and <b>add</b>. Their meaning is as follows. University <i>i</i> sends <b>count</b>[i] people. The name of the first participant from that university is <b>first</b>[i]. The name of the second participant from that university (say second[i]) is (<b>first</b>[i] * <b>mult</b>[i] + <b>add</b>[i]) modulo <b>M</b>. The name of the third one (say third[i]) is (second[i] * <b>mult</b>[i] + <b>add</b>[i]) modulo <b>M</b>, and so on. See the notes for important information about an efficient implementation of the given generation process.<br></br><br></br>

Return the maximum number of disjoint pairs in which the two people have different names.</td></tr><tr><td colspan="2"><h3>Definition</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Class:</td><td>EllysPairing</td></tr><tr><td>Method:</td><td>getMax</td></tr><tr><td>Parameters:</td><td>int, vector &lt;int&gt;, vector &lt;int&gt;, vector &lt;int&gt;, vector &lt;int&gt;</td></tr><tr><td>Returns:</td><td>int</td></tr><tr><td>Method signature:</td><td>int getMax(int M, vector &lt;int&gt; count, vector &lt;int&gt; first, vector &lt;int&gt; mult, vector &lt;int&gt; add)</td></tr><tr><td colspan="2">(be sure your method is public)</td></tr></table></td></tr><tr><td colspan="2"><h3>Limits</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Time limit (s):</td><td>2.000</td></tr><tr><td>Memory limit (MB):</td><td>16</td></tr></table></td></tr><tr><td colspan="2"><h3>Notes</h3></td></tr><tr><td align="center" valign="top">-</td><td>In order to make the generation of the names more efficient, it is guaranteed that <b>M</b> will be an exact power of two. Thus, instead of computing modulo <b>M</b>, the next name can be computed from the previous one by using the following formula: next = (previous * <b>mult</b>[i] + <b>add</b>[i]) & (<b>M</b> - 1). In this formula, '&' is the bitwise operator AND.</td></tr><tr><td align="center" valign="top">-</td><td>Depending on your programming language, you may make the generation of names even faster by using 32-bit integers only. Even though the multiplication may overflow, the & will then only select the bits we are interested in, and those will be correct. (Note that in C++ you should use <i>unsigned</i> 32-bit integers. Even though your code will probably also work with signed ints, signed integer overflow leads to undefined behavior in C++.)</td></tr><tr><td align="center" valign="top">-</td><td>The bitwise operator AND (the operator '&' in C++, Java, Python, and C#; the operator 'And' in VB) takes the binary representation of two numbers and creates a new number which has 1-bits only in the positions where both initial numbers had 1. For example 5 & 3 = 1, since 101 & 011 = 001.</td></tr><tr><td colspan="2"><h3>Constraints</h3></td></tr><tr><td align="center" valign="top">-</td><td><b>M</b> will be between 1 and 1,073,741,824, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>M</b> will be an exact power of two.</td></tr><tr><td align="center" valign="top">-</td><td><b>count</b>, <b>first</b>, <b>mult</b>, and <b>add</b> will contain between 1 and 50 elements, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td><b>count</b>, <b>first</b>, <b>mult</b>, and <b>add</b> will contain the same number of elements.</td></tr><tr><td align="center" valign="top">-</td><td>Each element of <b>count</b> will be between 1 and 1,000,000, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td>Each element of <b>first</b>, <b>mult</b>, and <b>add</b> will be between 0 and <b>M</b>-1, inclusive.</td></tr><tr><td colspan="2"><h3>Examples</h3></td></tr><tr><td align="center" nowrap="true">0)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>16</pre></td></tr><tr><td><pre>{4, 7}</pre></td></tr><tr><td><pre>{5, 3}</pre></td></tr><tr><td><pre>{2, 3}</pre></td></tr><tr><td><pre>{1, 0}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 5</pre></td></tr><tr><td><table><tr><td colspan="2">The people from university 0 have names {5, 7, 11, 15} and the ones from university 1 have names {1, 3, 3, 9, 9, 11, 11}.<br></br>
Since the number of people is odd, there can be at most 5 pairs altogether.<br></br>
It turns out that each of those pairs can contain two people with different names!<br></br>
One of the possible pairings is: {(5, 15), (7, 3), (11, 9), (1, 3), (9, 11)}.
</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">1)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>8</pre></td></tr><tr><td><pre>{6, 4, 3}</pre></td></tr><tr><td><pre>{0, 3, 2}</pre></td></tr><tr><td><pre>{3, 7, 5}</pre></td></tr><tr><td><pre>{0, 3, 2}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 5</pre></td></tr><tr><td><table><tr><td colspan="2">In this example the people have names {0, 3, 2, 0, 0, 4, 0, 3, 6, 0, 0, 0, 0}.<br></br>
In the best solution there are 5 pairs such that the two people have different names. Additionally, there is one pair in which both people have the same name and one other person without a partner.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">2)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>128</pre></td></tr><tr><td><pre>{42, 13, 666, 17, 1337, 42, 1}</pre></td></tr><tr><td><pre>{18, 76, 3, 122, 0, 11, 11}</pre></td></tr><tr><td><pre>{33, 17, 54, 90, 41, 122, 20}</pre></td></tr><tr><td><pre>{66, 15, 10, 121, 122, 1, 30}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 1059</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">3)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>1048576</pre></td></tr><tr><td><pre>{4242, 42, 9872, 13, 666, 21983, 17, 1337, 42, 1}</pre></td></tr><tr><td><pre>{19, 18, 76, 42, 3, 112, 0, 11, 11, 12}</pre></td></tr><tr><td><pre>{27, 33, 10, 8, 17, 9362, 90, 41, 122, 20}</pre></td></tr><tr><td><pre>{98, 101, 66, 15, 10, 144, 3, 1, 5, 1}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 16232</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">4)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>1073741824</pre></td></tr><tr><td><pre>{894602, 946569, 887230, 856152, 962583, 949356, 904847, 829100, 842183, 958440,
 811081, 864078, 809209, 938727, 949135, 892809, 816528, 961237, 979142, 890922}</pre></td></tr><tr><td><pre>{844085078, 898937259, 243490172, 887804102, 187696417, 156820442, 237600210, 618812924, 153000239, 912364033,
 254936966, 650298774, 982988140, 649258331, 566444626, 201481721, 492943390, 1061953081, 492672963, 960519711}</pre></td></tr><tr><td><pre>{1036482037, 583219072, 819168094, 253755052, 548208982, 401830167, 638626082, 43642932, 123607749, 485521178,
 860368129, 30334704, 219771462, 733375600, 130839219, 415503960, 294132484, 1044831462, 256910484, 198852170}</pre></td></tr><tr><td><pre>{889169006, 604831366, 967292994, 980686280, 844875791, 1027687492, 357734882, 295879743, 48284748, 421729100,
 1049536313, 327207332, 948053446, 271229570, 664579359, 795815285, 842856528, 876662975, 675611938, 634229925}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 8971965</pre></td></tr><tr><td><table><tr><td colspan="2">Don't forget that the memory limit for the problem is only 16 megabytes! We recommend that you test this example in the arena before you submit.</td></tr></table></td></tr></table></td></tr></table><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc.  Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited.  (c)2003, TopCoder, Inc.  All rights reserved.  </p></body></html>